# Javascript 函数

在 JS 中，函数也是一个对象。函数可以封装代码。函数具有普通对象的特点，比普通对象更强大。

一个标准的函数定义如下：

```javascript
function fun(){...}
```

</br>

### 基本操作

创建函数对象：可以将代码以字符串形式传递给构造函数。

```javascript
var fun = new Function(" ");
```

​	&nbsp;&nbsp;**函数声明**

```javascript
var fun = function(){...};
```

 \- 使用函数表达式声明赋值匿名函数的变量，是赋值语句。  
 \- 实际编程中并不会使用构造函数而是函数声明。  

​	&nbsp;&nbsp;**匿名函数**

创建一个立即调用函数表达式(IIFE)，只会执行一次。  
( `function` ( `形参` ){ `code` })( `实参` )  

调用函数对象：封装好的代码不会立即执行，只会在调用时执行。

```javascript
fun();
```

</br>

### 参数

定义函数时，在 () 中指定形式参数。若指定多个形参，用逗号隔开。指定参数相当于在函数内声明了对应的变量，但并不赋值。

在调用函数时，在 () 中指定实际参数。实参会赋值给对应的形式参数。

调用函数时解析器不会检查实参的类型，需要注意是否可能会接受到非法参数。  
解析器也不会检查实参的数量，如果实参的数量少于形参的数量，则没有对应实参的将是 undefined。  

</br>

### 返回值

可以使用 return 语句设置函数的返回值。

</br>

### 匿名函数

匿名函数在栈追踪中不会显示有意义的函数名，使调试困难。

比如在递归中，当函数需要引用自身时只能使用过期的 arguments.callee 引用。

</br>

### 回调函数

被作为实参传入另一函数，并在该外部函数内被调用，用以来完成某些任务的函数。

你没有调用该函数，但它最终被执行了。

```javascript
document.getElementById('btn').onclick = function() {
    ...}			// 一种常见的回调函数
```

</br>

### 上下文对象

解析器在调用函数每次都会向函数内部传递一个隐含的参数 this。**根据函数调用方式不同，this 会绑定不同的对象。**  
 \- 以函数形式调用时，this 绑定 window 对象。  
 \- 以方法形式调用时，this 绑定调用方法的对象。  
 \- 以构造函数形式调用时，this 绑定新创建的对象。  
 \- 使用 call()、apply()、bind() 方法调用时，this 绑定指定的对象。  
 \- 在全局作用域中 this 绑定 window 对象。  

**this 既不指向函数自身也不指向函数的词法作用域，this 是在函数被调用时发生的绑定。**

</br>

### call()、apply()、bind() 方法

使用 call()、apply()、bind() 方法调用函数，第一个参数指向对象。

call 的参数是直接放进去的，第二第三第 n 个参数全都用逗号分隔。

```javascript
var obj1 = {};
func.call(obj1);
obj.func.call(obj1, param1, param2, ..., paramX);
```

apply 的所有参数都必须放在一个数组里面传进去。

```javascript
var obj1 = {};
func.apply(obj1);
obj.func.apply(obj1, [param1, param2, ..., paramX]);
```

bind 除了返回是函数以外，它 的参数和 call 一样。

</br>

### Arguments 对象*

arguments 对象是所有（非箭头）函数中都可用的**局部变量**。你可以使用 arguments 对象在函数中引用函数的参数。此对象包含传递给函数的每个参数，第一个参数在索引 0 处。

```javascript
function fn1(1, 2, 3){		// arguments => [1, 2, 3]
```

arguments 对象不是一个 Array。它类似于 Array ，但除了 length 属性和索引元素之外没有任何 Array 属性。例如，它没有 [pop](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/pop) 方法。但它可以被转换为一个真正的 Array。

对参数使用 slice 会阻止某些 JS 引擎的优化。如果关心性能，尝试通过遍历 arguments 对象来构造一个新的数组。另一种方法是使用被忽视的 Array 构造函数作为一个函数。

​	**callee 属性**
arguments 具有的属性，表示正在执行的函数。

​	**length**
传递给函数的参数数量。

​	**arguments[@@iterator]**
返回一个新的 [Array 迭代器](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/@@iterator) 对象，该对象包含参数中每个索引的值。
 \- IE 不支持该属性。

在严格模式下，arguments[@@iterator] 不再与函数的实际形参之间共享，同时 callee 属性也被移除。当一个函数必须调用自身的时候，**避免使用** arguments.callee()，要么给函数表达式一个名字，要么使用一个函数声明。主要原因是递归调用会获取到一个不同的 `this` 值。
